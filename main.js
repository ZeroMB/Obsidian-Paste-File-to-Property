/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoFrontmatterConverterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  includeFileExtension: false
};
var AutoFrontmatterConverterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.registerDomEvent(document, "paste", this.handlePaste.bind(this), true);
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        this.handleEditorChange(editor);
      })
    );
    this.addSettingTab(new AutoFrontmatterConverterSettingTab(this.app, this));
    this.addCommand({
      id: "convert-frontmatter-references",
      name: "Convert frontmatter file references",
      editorCallback: (editor) => {
        this.convertFrontmatterReferences(editor);
      }
    });
  }
  async handlePaste(evt) {
    const activeEl = document.activeElement;
    if (this.isValidFrontmatterField(activeEl)) {
      await this.handleFilePasteInProperty(evt, activeEl);
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const editor = activeView.editor;
    if (!editor)
      return;
    setTimeout(() => {
      this.convertFrontmatterReferences(editor);
    }, 50);
  }
  isValidFrontmatterField(element) {
    if (!element)
      return false;
    return element.matches(".metadata-input-longtext.mod-truncate");
  }
  async handleFilePasteInProperty(evt, target) {
    if (!evt.clipboardData)
      return;
    if (evt.clipboardData.types[0] !== "Files")
      return;
    const items = evt.clipboardData.items;
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      if (item.kind === "file") {
        const file = item.getAsFile();
        if (file) {
          await this.saveFileAndWriteLink(file, target);
          evt.preventDefault();
          break;
        }
      }
    }
  }
  async saveFileAndWriteLink(file, target) {
    var _a, _b;
    const arrayBuffer = await file.arrayBuffer();
    const fileName = file.name || `Pasted file ${Date.now()}`;
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice(`No active file!`);
      return;
    }
    const savePath = await this.app.fileManager.getAvailablePathForAttachment(fileName, activeFile.path);
    const activeEl = document.activeElement;
    const propertyName = (_b = (_a = activeEl.parentNode) == null ? void 0 : _a.parentNode) == null ? void 0 : _b.children[0].children[1].getAttribute("aria-label");
    const newFile = await this.app.vault.createBinary(savePath, arrayBuffer);
    let displayName;
    const fileNameOnly = savePath.split("/").pop() || fileName;
    if (this.settings.includeFileExtension) {
      displayName = fileNameOnly;
    } else {
      displayName = fileNameOnly.replace(/\.[^/.]+$/, "");
    }
    const linkText = `[[${savePath}|${displayName}]]`;
    await this.writeLinkIntoFrontmatter(activeFile, linkText, activeEl, propertyName, newFile);
  }
  async writeLinkIntoFrontmatter(activeFile, filePath, activeEl, propertyName, newFile) {
    if (document.activeElement === activeEl)
      activeEl.blur();
    await new Promise((resolve) => setTimeout(resolve, 50));
    try {
      if (!propertyName)
        throw new Error("aria-label attribute not found on the expected element.");
      await this.app.fileManager.processFrontMatter(activeFile, (frontmatter) => {
        frontmatter[propertyName] = filePath;
      });
    } catch (error) {
      await this.app.vault.delete(newFile);
      new import_obsidian.Notice(`Failed to update frontmatter!
${error}`);
      console.error("Error updating frontmatter:", error);
    }
  }
  handleEditorChange(editor) {
    clearTimeout(this.changeTimeout);
    this.changeTimeout = setTimeout(() => {
      this.convertFrontmatterReferences(editor);
    }, 300);
  }
  convertFrontmatterReferences(editor) {
    const content = editor.getValue();
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch)
      return;
    const frontmatter = frontmatterMatch[1];
    const beforeFrontmatter = content.substring(0, frontmatterMatch.index + 4);
    const afterFrontmatter = content.substring(frontmatterMatch.index + frontmatterMatch[0].length);
    const regex = /!\[\[([^\]]+)\]\]/g;
    if (!regex.test(frontmatter))
      return;
    regex.lastIndex = 0;
    const newFrontmatter = frontmatter.replace(regex, (match, filepath) => {
      let filename;
      if (this.settings.includeFileExtension) {
        filename = filepath.split("/").pop() || filepath;
      } else {
        const fullFilename = filepath.split("/").pop() || filepath;
        filename = fullFilename.replace(/\.[^/.]+$/, "");
      }
      return `"[[${filepath}|${filename}]]"`;
    });
    if (newFrontmatter !== frontmatter) {
      const newContent = beforeFrontmatter + newFrontmatter + "\n---" + afterFrontmatter;
      const cursor = editor.getCursor();
      editor.setValue(newContent);
      editor.setCursor(cursor);
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var AutoFrontmatterConverterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Show file extension").setDesc("Show or hide file extensions in names.").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeFileExtension).onChange(async (value) => {
      this.plugin.settings.includeFileExtension = value;
      await this.plugin.saveSettings();
    }));
  }
};
